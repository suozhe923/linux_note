<p>#the key is in ~/.ssh/id_rsa</p>
<ul>
<li><code>git help &lt;command&gt;</code>: get help for a git
command</li>
<li><code>git init</code>: creates a new git repo, with data stored in
the <code>.git</code> directory</li>
<li><code>git status</code>: tells you what’s going on</li>
<li><code>git add &lt;filename&gt;</code>: adds files to staging
area</li>
<li><code>git commit</code>: creates a new commit
<ul>
<li>Write <a
href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">good
commit messages</a>!</li>
<li>Even more reasons to write <a
href="https://chris.beams.io/posts/git-commit/">good commit
messages</a>!</li>
</ul></li>
<li><code>git log</code>: shows a flattened log of history</li>
<li><code>git log --all --graph --decorate</code>: visualizes history as
a DAG</li>
<li><code>git diff &lt;filename&gt;</code>: show changes you made
relative to the staging area</li>
<li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: shows
differences in a file between snapshots</li>
<li><code>git checkout &lt;revision&gt;</code>: updates HEAD and current
branch</li>
</ul>
<h2 id="branching-and-merging">Branching and merging</h2>
<p>{% comment %}</p>
<p>Branching allows you to “fork” version history. It can be helpful for
working on independent features or bug fixes in parallel. The
<code>git branch</code> command can be used to create new branches;
<code>git checkout -b &lt;branch name&gt;</code> creates and branch and
checks it out.</p>
<p>Merging is the opposite of branching: it allows you to combine forked
version histories, e.g. merging a feature branch back into master. The
<code>git merge</code> command is used for merging.</p>
<p>{% endcomment %}</p>
<ul>
<li><code>git branch</code>: shows branches</li>
<li><code>git branch &lt;name&gt;</code>: creates a branch</li>
<li><code>git checkout -b &lt;name&gt;</code>: creates a branch and
switches to it
<ul>
<li>same as
<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li>
</ul></li>
<li><code>git merge &lt;revision&gt;</code>: merges into current
branch</li>
<li><code>git mergetool</code>: use a fancy tool to help resolve merge
conflicts</li>
<li><code>git rebase</code>: rebase set of patches onto a new base</li>
</ul>
<h2 id="remotes">Remotes</h2>
<ul>
<li><code>git remote</code>: list remotes</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: add a
remote</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:
send objects to remote, and update remote reference</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:
set up correspondence between local and remote branch</li>
<li><code>git fetch</code>: retrieve objects/references from a
remote</li>
<li><code>git pull</code>: same as
<code>git fetch; git merge</code></li>
<li><code>git clone</code>: download repository from remote</li>
</ul>
<h2 id="undo">Undo</h2>
<ul>
<li><code>git commit --amend</code>: edit a commit’s
contents/message</li>
<li><code>git reset HEAD &lt;file&gt;</code>: unstage a file</li>
<li><code>git checkout -- &lt;file&gt;</code>: discard changes</li>
</ul>
<h1 id="advanced-git">Advanced Git</h1>
<ul>
<li><code>git config</code>: Git is <a
href="https://git-scm.com/docs/git-config">highly customizable</a></li>
<li><code>git clone --depth=1</code>: shallow clone, without entire
version history</li>
<li><code>git add -p</code>: interactive staging</li>
<li><code>git rebase -i</code>: interactive rebasing</li>
<li><code>git blame</code>: show who last edited which line</li>
<li><code>git stash</code>: temporarily remove modifications to working
directory</li>
<li><code>git bisect</code>: binary search history (e.g. for
regressions)</li>
<li><code>.gitignore</code>: <a
href="https://git-scm.com/docs/gitignore">specify</a> intentionally
untracked files to ignore</li>
</ul>
<h1 id="miscellaneous">Miscellaneous</h1>
<ul>
<li><strong>GUIs</strong>: there are many <a
href="https://git-scm.com/downloads/guis">GUI clients</a> out there for
Git. We personally don’t use them and use the command-line interface
instead.</li>
<li><strong>Shell integration</strong>: it’s super handy to have a Git
status as part of your shell prompt (<a
href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a
href="https://github.com/magicmonty/bash-git-prompt">bash</a>). Often
included in frameworks like <a
href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>.</li>
<li><strong>Editor integration</strong>: similarly to the above, handy
integrations with many features. <a
href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> is the
standard one for Vim.</li>
<li><strong>Workflows</strong>: we taught you the data model, plus some
basic commands; we didn’t tell you what practices to follow when working
on big projects (and there are <a
href="https://nvie.com/posts/a-successful-git-branching-model/">many</a>
<a
href="https://www.endoflineblog.com/gitflow-considered-harmful">different</a>
<a
href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">approaches</a>).</li>
<li><strong>GitHub</strong>: Git is not GitHub. GitHub has a specific
way of contributing code to other projects, called <a
href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">pull
requests</a>.</li>
<li><strong>Other Git providers</strong>: GitHub is not special: there
are many Git repository hosts, like <a
href="https://about.gitlab.com/">GitLab</a> and <a
href="https://bitbucket.org/">BitBucket</a>.</li>
</ul>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> is
<strong>highly recommended reading</strong>. Going through Chapters 1–5
should teach you most of what you need to use Git proficiently, now that
you understand the data model. The later chapters have some interesting,
advanced material.</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> is a short
guide on how to recover from some common Git mistakes.</li>
<li><a
href="https://eagain.net/articles/git-for-computer-scientists/">Git for
Computer Scientists</a> is a short explanation of Git’s data model, with
less pseudocode and more fancy diagrams than these lecture notes.</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git
from the Bottom Up</a> is a detailed explanation of Git’s implementation
details beyond just the data model, for the curious.</li>
<li><a
href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How
to explain git in simple words</a></li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a>
is a browser-based game that teaches you Git.</li>
</ul>
<h1 id="exercises">Exercises</h1>
<ol type="1">
<li>If you don’t have any past experience with Git, either try reading
the first couple chapters of <a
href="https://git-scm.com/book/en/v2">Pro Git</a> or go through a
tutorial like <a href="https://learngitbranching.js.org/">Learn Git
Branching</a>. As you’re working through it, relate Git commands to the
data model.</li>
<li>Clone the <a
href="https://github.com/missing-semester/missing-semester">repository
for the class website</a>.
<ol type="1">
<li>Explore the version history by visualizing it as a graph.</li>
<li>Who was the last person to modify <code>README.md</code>? (Hint: use
<code>git log</code> with an argument).</li>
<li>What was the commit message associated with the last modification to
the <code>collections:</code> line of <code>_config.yml</code>? (Hint:
use <code>git blame</code> and <code>git     show</code>).</li>
</ol></li>
<li>One common mistake when learning Git is to commit large files that
should not be managed by Git or adding sensitive information. Try adding
a file to a repository, making some commits and then deleting that file
from history (you may want to look at <a
href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">this</a>).</li>
<li>Clone some repository from GitHub, and modify one of its existing
files. What happens when you do <code>git stash</code>? What do you see
when running <code>git log    --all --oneline</code>? Run
<code>git stash pop</code> to undo what you did with
<code>git stash</code>. In what scenario might this be useful?</li>
<li>Like many command line tools, Git provides a configuration file (or
dotfile) called <code>~/.gitconfig</code>. Create an alias in
<code>~/.gitconfig</code> so that when you run <code>git graph</code>,
you get the output of
<code>git log --all --graph --decorate    --oneline</code>. You can do
this by directly <a
href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias">editing</a>
the <code>~/.gitconfig</code> file, or you can use the
<code>git config</code> command to add the alias. Information about git
aliases can be found <a
href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases">here</a>.</li>
<li>You can define global ignore patterns in
<code>~/.gitignore_global</code> after running
<code>git config --global core.excludesfile ~/.gitignore_global</code>.
Do this, and set up your global gitignore file to ignore OS-specific or
editor-specific temporary files, like <code>.DS_Store</code>.</li>
<li>Fork the <a
href="https://github.com/missing-semester/missing-semester">repository
for the class website</a>, find a typo or some other improvement you can
make, and submit a pull request on GitHub (you may want to look at <a
href="https://github.com/firstcontributions/first-contributions">this</a>).
Please only submit PRs that are useful (don’t spam us, please!). If you
can’t find an improvement to make, you can skip this exercise.</li>
</ol>
